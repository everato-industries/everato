// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0

package repository

import (
	"database/sql/driver"
	"fmt"

	"github.com/jackc/pgx/v5/pgtype"
)

type BookingStatus string

const (
	BookingStatusPENDING        BookingStatus = "PENDING"
	BookingStatusPENDINGPAYMENT BookingStatus = "PENDING_PAYMENT"
	BookingStatusTIMEOUT        BookingStatus = "TIMEOUT"
	BookingStatusFILLED         BookingStatus = "FILLED"
	BookingStatusCONFIRMED      BookingStatus = "CONFIRMED"
	BookingStatusCANCELLED      BookingStatus = "CANCELLED"
)

func (e *BookingStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BookingStatus(s)
	case string:
		*e = BookingStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for BookingStatus: %T", src)
	}
	return nil
}

type NullBookingStatus struct {
	BookingStatus BookingStatus `json:"booking_status"`
	Valid         bool          `json:"valid"` // Valid is true if BookingStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBookingStatus) Scan(value interface{}) error {
	if value == nil {
		ns.BookingStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BookingStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBookingStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BookingStatus), nil
}

func (e BookingStatus) Valid() bool {
	switch e {
	case BookingStatusPENDING,
		BookingStatusPENDINGPAYMENT,
		BookingStatusTIMEOUT,
		BookingStatusFILLED,
		BookingStatusCONFIRMED,
		BookingStatusCANCELLED:
		return true
	}
	return false
}

type PaymentStatus string

const (
	PaymentStatusDONE      PaymentStatus = "DONE"
	PaymentStatusCANCELLED PaymentStatus = "CANCELLED"
	PaymentStatusTIMEOUT   PaymentStatus = "TIMEOUT"
	PaymentStatusFAILED    PaymentStatus = "FAILED"
	PaymentStatusREJECTED  PaymentStatus = "REJECTED"
)

func (e *PaymentStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PaymentStatus(s)
	case string:
		*e = PaymentStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for PaymentStatus: %T", src)
	}
	return nil
}

type NullPaymentStatus struct {
	PaymentStatus PaymentStatus `json:"payment_status"`
	Valid         bool          `json:"valid"` // Valid is true if PaymentStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPaymentStatus) Scan(value interface{}) error {
	if value == nil {
		ns.PaymentStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PaymentStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPaymentStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PaymentStatus), nil
}

func (e PaymentStatus) Valid() bool {
	switch e {
	case PaymentStatusDONE,
		PaymentStatusCANCELLED,
		PaymentStatusTIMEOUT,
		PaymentStatusFAILED,
		PaymentStatusREJECTED:
		return true
	}
	return false
}

type PaymentType string

const (
	PaymentTypeUPISS   PaymentType = "UPI_SS"
	PaymentTypeGATEWAY PaymentType = "GATEWAY"
)

func (e *PaymentType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PaymentType(s)
	case string:
		*e = PaymentType(s)
	default:
		return fmt.Errorf("unsupported scan type for PaymentType: %T", src)
	}
	return nil
}

type NullPaymentType struct {
	PaymentType PaymentType `json:"payment_type"`
	Valid       bool        `json:"valid"` // Valid is true if PaymentType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPaymentType) Scan(value interface{}) error {
	if value == nil {
		ns.PaymentType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PaymentType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPaymentType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PaymentType), nil
}

func (e PaymentType) Valid() bool {
	switch e {
	case PaymentTypeUPISS,
		PaymentTypeGATEWAY:
		return true
	}
	return false
}

type Permissions string

const (
	PermissionsMANAGEEVENTS   Permissions = "MANAGE_EVENTS"
	PermissionsCREATEEVENT    Permissions = "CREATE_EVENT"
	PermissionsEDITEVENT      Permissions = "EDIT_EVENT"
	PermissionsDELETEEVENT    Permissions = "DELETE_EVENT"
	PermissionsVIEWEVENT      Permissions = "VIEW_EVENT"
	PermissionsMANAGEBOOKINGS Permissions = "MANAGE_BOOKINGS"
	PermissionsCREATEBOOKING  Permissions = "CREATE_BOOKING"
	PermissionsEDITBOOKING    Permissions = "EDIT_BOOKING"
	PermissionsDELETEBOOKING  Permissions = "DELETE_BOOKING"
	PermissionsVIEWBOOKING    Permissions = "VIEW_BOOKING"
	PermissionsMANAGEUSERS    Permissions = "MANAGE_USERS"
	PermissionsVIEWREPORTS    Permissions = "VIEW_REPORTS"
)

func (e *Permissions) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Permissions(s)
	case string:
		*e = Permissions(s)
	default:
		return fmt.Errorf("unsupported scan type for Permissions: %T", src)
	}
	return nil
}

type NullPermissions struct {
	Permissions Permissions `json:"permissions"`
	Valid       bool        `json:"valid"` // Valid is true if Permissions is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPermissions) Scan(value interface{}) error {
	if value == nil {
		ns.Permissions, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Permissions.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPermissions) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Permissions), nil
}

func (e Permissions) Valid() bool {
	switch e {
	case PermissionsMANAGEEVENTS,
		PermissionsCREATEEVENT,
		PermissionsEDITEVENT,
		PermissionsDELETEEVENT,
		PermissionsVIEWEVENT,
		PermissionsMANAGEBOOKINGS,
		PermissionsCREATEBOOKING,
		PermissionsEDITBOOKING,
		PermissionsDELETEBOOKING,
		PermissionsVIEWBOOKING,
		PermissionsMANAGEUSERS,
		PermissionsVIEWREPORTS:
		return true
	}
	return false
}

type SuperUserRole string

const (
	SuperUserRoleSUPERADMIN SuperUserRole = "SUPER_ADMIN"
	SuperUserRoleADMIN      SuperUserRole = "ADMIN"
	SuperUserRoleEDITOR     SuperUserRole = "EDITOR"
)

func (e *SuperUserRole) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SuperUserRole(s)
	case string:
		*e = SuperUserRole(s)
	default:
		return fmt.Errorf("unsupported scan type for SuperUserRole: %T", src)
	}
	return nil
}

type NullSuperUserRole struct {
	SuperUserRole SuperUserRole `json:"super_user_role"`
	Valid         bool          `json:"valid"` // Valid is true if SuperUserRole is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSuperUserRole) Scan(value interface{}) error {
	if value == nil {
		ns.SuperUserRole, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SuperUserRole.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSuperUserRole) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SuperUserRole), nil
}

func (e SuperUserRole) Valid() bool {
	switch e {
	case SuperUserRoleSUPERADMIN,
		SuperUserRoleADMIN,
		SuperUserRoleEDITOR:
		return true
	}
	return false
}

type TicketStatus string

const (
	TicketStatusBOOKED    TicketStatus = "BOOKED"
	TicketStatusCANCELLED TicketStatus = "CANCELLED"
	TicketStatusTIMEOUT   TicketStatus = "TIMEOUT"
	TicketStatusFAILED    TicketStatus = "FAILED"
)

func (e *TicketStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TicketStatus(s)
	case string:
		*e = TicketStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for TicketStatus: %T", src)
	}
	return nil
}

type NullTicketStatus struct {
	TicketStatus TicketStatus `json:"ticket_status"`
	Valid        bool         `json:"valid"` // Valid is true if TicketStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTicketStatus) Scan(value interface{}) error {
	if value == nil {
		ns.TicketStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TicketStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTicketStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TicketStatus), nil
}

func (e TicketStatus) Valid() bool {
	switch e {
	case TicketStatusBOOKED,
		TicketStatusCANCELLED,
		TicketStatusTIMEOUT,
		TicketStatusFAILED:
		return true
	}
	return false
}

type Booking struct {
	ID        pgtype.UUID        `json:"id"`
	EventID   pgtype.UUID        `json:"event_id"`
	UserID    pgtype.UUID        `json:"user_id"`
	CouponID  pgtype.UUID        `json:"coupon_id"`
	Status    BookingStatus      `json:"status"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

type Coupon struct {
	ID                 pgtype.UUID        `json:"id"`
	EventID            pgtype.UUID        `json:"event_id"`
	Code               string             `json:"code"`
	DiscountPercentage float64            `json:"discount_percentage"`
	ValidFrom          pgtype.Timestamptz `json:"valid_from"`
	ValidUntil         pgtype.Timestamptz `json:"valid_until"`
	UsageLimit         int32              `json:"usage_limit"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
}

type Event struct {
	ID             pgtype.UUID        `json:"id"`
	Title          string             `json:"title"`
	Description    string             `json:"description"`
	Banner         string             `json:"banner"`
	Icon           string             `json:"icon"`
	AdminID        pgtype.UUID        `json:"admin_id"`
	StartTime      pgtype.Timestamptz `json:"start_time"`
	EndTime        pgtype.Timestamptz `json:"end_time"`
	Location       pgtype.Text        `json:"location"`
	TotalSeats     int32              `json:"total_seats"`
	AvailableSeats int32              `json:"available_seats"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	Slug           string             `json:"slug"`
}

type Payment struct {
	ID       pgtype.UUID   `json:"id"`
	Amount   float64       `json:"amount"`
	Type     PaymentType   `json:"type"`
	Status   PaymentStatus `json:"status"`
	EventID  pgtype.UUID   `json:"event_id"`
	UserID   pgtype.UUID   `json:"user_id"`
	TicketID pgtype.UUID   `json:"ticket_id"`
}

type SuperUser struct {
	ID          pgtype.UUID        `json:"id"`
	Email       string             `json:"email"`
	Password    string             `json:"password"`
	Role        SuperUserRole      `json:"role"`
	Permissions []Permissions      `json:"permissions"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	Username    string             `json:"username"`
	Name        string             `json:"name"`
}

type Ticket struct {
	ID         pgtype.UUID  `json:"id"`
	Price      float64      `json:"price"`
	Status     TicketStatus `json:"status"`
	EventID    pgtype.UUID  `json:"event_id"`
	UserID     pgtype.UUID  `json:"user_id"`
	TicketType pgtype.UUID  `json:"ticket_type"`
	BookingID  pgtype.UUID  `json:"booking_id"`
	QrCode     pgtype.Text  `json:"qr_code"`
}

type TicketType struct {
	ID               pgtype.UUID `json:"id"`
	Name             string      `json:"name"`
	EventID          pgtype.UUID `json:"event_id"`
	Price            float64     `json:"price"`
	AvailableTickets int32       `json:"available_tickets"`
}

type User struct {
	ID        pgtype.UUID        `json:"id"`
	FirstName string             `json:"first_name"`
	LastName  string             `json:"last_name"`
	Email     string             `json:"email"`
	Password  string             `json:"password"`
	Verified  bool               `json:"verified"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}
