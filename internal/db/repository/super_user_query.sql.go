// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: super_user_query.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAdminIfNotExists = `-- name: CreateAdminIfNotExists :one
INSERT INTO super_users (username, name, email, password, role, permissions)
SELECT
    $1,
    $2,
    $3,
    $4,
    $5::SUPER_USER_ROLE,
    $6::PERMISSIONS[]
WHERE NOT EXISTS (
    SELECT 1 FROM super_users WHERE username = $1 OR email = $3
)
RETURNING id, email, password, role, permissions, created_at, updated_at, username, name
`

type CreateAdminIfNotExistsParams struct {
	Username string
	Name     string
	Email    string
	Password string
	Column5  SuperUserRole
	Column6  []Permissions
}

func (q *Queries) CreateAdminIfNotExists(ctx context.Context, arg CreateAdminIfNotExistsParams) (SuperUser, error) {
	row := q.db.QueryRow(ctx, createAdminIfNotExists,
		arg.Username,
		arg.Name,
		arg.Email,
		arg.Password,
		arg.Column5,
		arg.Column6,
	)
	var i SuperUser
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.Role,
		&i.Permissions,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Username,
		&i.Name,
	)
	return i, err
}

const createSuperUserIfNotExists = `-- name: CreateSuperUserIfNotExists :one
INSERT INTO super_users (username, name, email, password, role, permissions)
SELECT
    $1::VARCHAR,
    $2::VARCHAR,
    $3::VARCHAR,
    $4::VARCHAR,
    'SUPER_ADMIN'::SUPER_USER_ROLE,
    ARRAY[
        'MANAGE_EVENTS',
        'CREATE_EVENT',
        'EDIT_EVENT',
        'DELETE_EVENT',
        'VIEW_EVENT',
        'MANAGE_BOOKINGS',
        'CREATE_BOOKING',
        'EDIT_BOOKING',
        'DELETE_BOOKING',
        'VIEW_BOOKING',
        'MANAGE_USERS',
        'VIEW_REPORTS'
    ]::PERMISSIONS[]
WHERE NOT EXISTS (
    SELECT 1 FROM super_users WHERE username = $1::VARCHAR OR email = $3::VARCHAR
)
RETURNING id, email, password, role, permissions::text[], created_at, updated_at, username, name
`

type CreateSuperUserIfNotExistsParams struct {
	Column1 string
	Column2 string
	Column3 string
	Column4 string
}

type CreateSuperUserIfNotExistsRow struct {
	ID          pgtype.UUID
	Email       string
	Password    string
	Role        SuperUserRole
	Permissions []string
	CreatedAt   pgtype.Timestamptz
	UpdatedAt   pgtype.Timestamptz
	Username    string
	Name        string
}

func (q *Queries) CreateSuperUserIfNotExists(ctx context.Context, arg CreateSuperUserIfNotExistsParams) (CreateSuperUserIfNotExistsRow, error) {
	row := q.db.QueryRow(ctx, createSuperUserIfNotExists,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	var i CreateSuperUserIfNotExistsRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.Role,
		&i.Permissions,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Username,
		&i.Name,
	)
	return i, err
}

const getAdminByEmail = `-- name: GetAdminByEmail :one
SELECT id, email, password, role, permissions::text[], created_at, updated_at, username, name
FROM super_users
WHERE email = $1
`

type GetAdminByEmailRow struct {
	ID          pgtype.UUID
	Email       string
	Password    string
	Role        SuperUserRole
	Permissions []string
	CreatedAt   pgtype.Timestamptz
	UpdatedAt   pgtype.Timestamptz
	Username    string
	Name        string
}

func (q *Queries) GetAdminByEmail(ctx context.Context, email string) (GetAdminByEmailRow, error) {
	row := q.db.QueryRow(ctx, getAdminByEmail, email)
	var i GetAdminByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.Role,
		&i.Permissions,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Username,
		&i.Name,
	)
	return i, err
}

const getAdminById = `-- name: GetAdminById :one
SELECT id, email, password, role, permissions::text[], created_at, updated_at, username, name
FROM super_users
WHERE id = $1
`

type GetAdminByIdRow struct {
	ID          pgtype.UUID
	Email       string
	Password    string
	Role        SuperUserRole
	Permissions []string
	CreatedAt   pgtype.Timestamptz
	UpdatedAt   pgtype.Timestamptz
	Username    string
	Name        string
}

func (q *Queries) GetAdminById(ctx context.Context, id pgtype.UUID) (GetAdminByIdRow, error) {
	row := q.db.QueryRow(ctx, getAdminById, id)
	var i GetAdminByIdRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.Role,
		&i.Permissions,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Username,
		&i.Name,
	)
	return i, err
}

const getAdminByUsername = `-- name: GetAdminByUsername :one
SELECT id, email, password, role, permissions::text[], created_at, updated_at, username, name
FROM super_users
WHERE username = $1
`

type GetAdminByUsernameRow struct {
	ID          pgtype.UUID
	Email       string
	Password    string
	Role        SuperUserRole
	Permissions []string
	CreatedAt   pgtype.Timestamptz
	UpdatedAt   pgtype.Timestamptz
	Username    string
	Name        string
}

func (q *Queries) GetAdminByUsername(ctx context.Context, username string) (GetAdminByUsernameRow, error) {
	row := q.db.QueryRow(ctx, getAdminByUsername, username)
	var i GetAdminByUsernameRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.Role,
		&i.Permissions,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Username,
		&i.Name,
	)
	return i, err
}

const getAdminPermissions = `-- name: GetAdminPermissions :many
SELECT e.enumlabel AS value
FROM pg_catalog.pg_type AS t
JOIN pg_catalog.pg_enum AS e ON t.oid = e.enumtypid
WHERE t.typname = 'permissions'
`

func (q *Queries) GetAdminPermissions(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getAdminPermissions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var value string
		if err := rows.Scan(&value); err != nil {
			return nil, err
		}
		items = append(items, value)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAdminUserRoles = `-- name: GetAdminUserRoles :many
SELECT e.enumlabel AS value
FROM pg_catalog.pg_type AS t
JOIN pg_catalog.pg_enum AS e ON t.oid = e.enumtypid
WHERE t.typname = 'super_user_role'
`

func (q *Queries) GetAdminUserRoles(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getAdminUserRoles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var value string
		if err := rows.Scan(&value); err != nil {
			return nil, err
		}
		items = append(items, value)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
